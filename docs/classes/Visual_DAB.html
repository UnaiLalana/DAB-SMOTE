<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>classes.Visual_DAB API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>classes.Visual_DAB</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="classes.Visual_DAB.Visual_DAB"><code class="flex name class">
<span>class <span class="ident">Visual_DAB</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visual_DAB(DAB_SMOTE.DAB_SMOTE):
    &#34;&#34;&#34;
    A visualization and debugging extension of the DAB_SMOTE oversampling algorithm.

    This class inherits from :class:`DAB_SMOTE.DAB_SMOTE` and exposes internal
    debugging methods that are otherwise private in the parent class.
    It is intended for visualization, inspection, and step-by-step analysis of
    the synthetic data generation process.

    Parameters
    ----------
    **kwargs : dict
        Arbitrary keyword arguments passed to the parent class constructor
        (:class:`DAB_SMOTE.DAB_SMOTE`). See its documentation for details.

    Examples
    --------
    &gt;&gt;&gt; from Visual_DAB import Visual_DAB
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.random.rand(100, 2)
    &gt;&gt;&gt; y = np.array([0]*90 + [1]*10)
    &gt;&gt;&gt; visual = Visual_DAB()
    &gt;&gt;&gt; X_res, y_res = visual.fit_resample(X, y)
    &gt;&gt;&gt; visual.summary
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Initialize a new instance of the Visual_DAB class.

        Parameters
        ----------
        **kwargs : dict
            Keyword arguments forwarded to the :class:`DAB_SMOTE.DAB_SMOTE` constructor.
        &#34;&#34;&#34;
        super().__init__(**kwargs)

    def get_removed_samples(self, Xmin: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Return filtered minority samples after removing noise.

        This method is intended for debugging only. It exposes the internal
        noise removal process used in the DAB_SMOTE algorithm to identify and
        remove outliers from the minority class.

        Parameters
        ----------
        Xmin : np.ndarray
            Array containing minority class samples.

        Returns
        -------
        np.ndarray
            Filtered array of minority class samples with noisy instances removed.
        &#34;&#34;&#34;
        return self._removeNoisySamples(Xmin)

    def get_clustering(self, Xmin: np.ndarray, solver: str = &#39;means&#39;) -&gt; tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Return clustering results of the minority samples.

        Performs DBSCAN clustering on the minority class samples and
        computes cluster centers using the specified solver method.

        Parameters
        ----------
        Xmin : np.ndarray
            Minority class samples to be clustered.
        solver : {&#39;means&#39;, &#39;density&#39;}, default=&#39;means&#39;
            Method to compute cluster centers. If &#39;means&#39;, centers are the mean
            of cluster points. If &#39;density&#39;, the densest point is used as the center.

        Returns
        -------
        tuple of (np.ndarray, np.ndarray)
            A tuple containing:
            - centers : np.ndarray
                Array of cluster centers.
            - clusters : np.ndarray
                Cluster label assigned to each sample.
        &#34;&#34;&#34;
        self._solver = solver
        return self._clustering(Xmin)

    def get_screened_boundaries(self, Xmin: np.ndarray, clusters: np.ndarray) -&gt; list[np.ndarray]:
        &#34;&#34;&#34;
        Return detected boundary samples of the minority class clusters.

        Identifies boundary samples based on deviation from cluster means and
        standard deviations, which are used later to guide synthetic sample generation.

        Parameters
        ----------
        Xmin : np.ndarray
            Minority class samples.
        clusters : np.ndarray
            Array of cluster labels corresponding to each sample.

        Returns
        -------
        list of np.ndarray
            List containing arrays of boundary samples for each cluster.
        &#34;&#34;&#34;
        return self._screenBoundarySamples(Xmin, clusters)

    def get_generated_samples(self, Xmin: np.ndarray, borders: list, clusters: np.ndarray, centers: np.ndarray, N: int) -&gt; np.ndarray | None:
        &#34;&#34;&#34;
        Return synthetic samples generated by the DAB_SMOTE algorithm.

        Generates new synthetic samples between boundary and cluster samples
        based on the interpolation and density-adaptive balancing mechanism of DAB_SMOTE.

        Parameters
        ----------
        Xmin : np.ndarray
            Minority class samples.
        borders : list of np.ndarray
            Boundary samples detected for each cluster.
        clusters : np.ndarray
            Cluster labels of the samples.
        centers : np.ndarray
            Centers of each cluster.
        N : int
            Number of new synthetic samples to generate.

        Returns
        -------
        np.ndarray or None
            Array of generated synthetic samples, or None if generation fails.
        &#34;&#34;&#34;
        return self._generateNewSamples(Xmin, borders, clusters, centers, N)</code></pre>
</details>
<div class="desc"><p>A visualization and debugging extension of the DAB_SMOTE oversampling algorithm.</p>
<p>This class inherits from :class:<code>DAB_SMOTE.DAB_SMOTE</code> and exposes internal
debugging methods that are otherwise private in the parent class.
It is intended for visualization, inspection, and step-by-step analysis of
the synthetic data generation process.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arbitrary keyword arguments passed to the parent class constructor
(:class:<code>DAB_SMOTE.DAB_SMOTE</code>). See its documentation for details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from Visual_DAB import Visual_DAB
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; X = np.random.rand(100, 2)
&gt;&gt;&gt; y = np.array([0]*90 + [1]*10)
&gt;&gt;&gt; visual = Visual_DAB()
&gt;&gt;&gt; X_res, y_res = visual.fit_resample(X, y)
&gt;&gt;&gt; visual.summary
</code></pre>
<p>Initialize a new instance of the Visual_DAB class.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments forwarded to the :class:<code>DAB_SMOTE.DAB_SMOTE</code> constructor.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="classes.DAB_SMOTE.DAB_SMOTE" href="DAB_SMOTE.html#classes.DAB_SMOTE.DAB_SMOTE">DAB_SMOTE</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="classes.Visual_DAB.Visual_DAB.get_clustering"><code class="name flex">
<span>def <span class="ident">get_clustering</span></span>(<span>self, Xmin: numpy.ndarray, solver: str = 'means') ‑> tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clustering(self, Xmin: np.ndarray, solver: str = &#39;means&#39;) -&gt; tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;
    Return clustering results of the minority samples.

    Performs DBSCAN clustering on the minority class samples and
    computes cluster centers using the specified solver method.

    Parameters
    ----------
    Xmin : np.ndarray
        Minority class samples to be clustered.
    solver : {&#39;means&#39;, &#39;density&#39;}, default=&#39;means&#39;
        Method to compute cluster centers. If &#39;means&#39;, centers are the mean
        of cluster points. If &#39;density&#39;, the densest point is used as the center.

    Returns
    -------
    tuple of (np.ndarray, np.ndarray)
        A tuple containing:
        - centers : np.ndarray
            Array of cluster centers.
        - clusters : np.ndarray
            Cluster label assigned to each sample.
    &#34;&#34;&#34;
    self._solver = solver
    return self._clustering(Xmin)</code></pre>
</details>
<div class="desc"><p>Return clustering results of the minority samples.</p>
<p>Performs DBSCAN clustering on the minority class samples and
computes cluster centers using the specified solver method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xmin</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Minority class samples to be clustered.</dd>
<dt><strong><code>solver</code></strong> :&ensp;<code>{'means', 'density'}</code>, default=<code>'means'</code></dt>
<dd>Method to compute cluster centers. If 'means', centers are the mean
of cluster points. If 'density', the densest point is used as the center.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>(np.ndarray, np.ndarray)</code></dt>
<dd>A tuple containing:
- centers : np.ndarray
Array of cluster centers.
- clusters : np.ndarray
Cluster label assigned to each sample.</dd>
</dl></div>
</dd>
<dt id="classes.Visual_DAB.Visual_DAB.get_generated_samples"><code class="name flex">
<span>def <span class="ident">get_generated_samples</span></span>(<span>self,<br>Xmin: numpy.ndarray,<br>borders: list,<br>clusters: numpy.ndarray,<br>centers: numpy.ndarray,<br>N: int) ‑> numpy.ndarray | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_generated_samples(self, Xmin: np.ndarray, borders: list, clusters: np.ndarray, centers: np.ndarray, N: int) -&gt; np.ndarray | None:
    &#34;&#34;&#34;
    Return synthetic samples generated by the DAB_SMOTE algorithm.

    Generates new synthetic samples between boundary and cluster samples
    based on the interpolation and density-adaptive balancing mechanism of DAB_SMOTE.

    Parameters
    ----------
    Xmin : np.ndarray
        Minority class samples.
    borders : list of np.ndarray
        Boundary samples detected for each cluster.
    clusters : np.ndarray
        Cluster labels of the samples.
    centers : np.ndarray
        Centers of each cluster.
    N : int
        Number of new synthetic samples to generate.

    Returns
    -------
    np.ndarray or None
        Array of generated synthetic samples, or None if generation fails.
    &#34;&#34;&#34;
    return self._generateNewSamples(Xmin, borders, clusters, centers, N)</code></pre>
</details>
<div class="desc"><p>Return synthetic samples generated by the DAB_SMOTE algorithm.</p>
<p>Generates new synthetic samples between boundary and cluster samples
based on the interpolation and density-adaptive balancing mechanism of DAB_SMOTE.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xmin</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Minority class samples.</dd>
<dt><strong><code>borders</code></strong> :&ensp;<code>list</code> of <code>np.ndarray</code></dt>
<dd>Boundary samples detected for each cluster.</dd>
<dt><strong><code>clusters</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Cluster labels of the samples.</dd>
<dt><strong><code>centers</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Centers of each cluster.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of new synthetic samples to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code> or <code>None</code></dt>
<dd>Array of generated synthetic samples, or None if generation fails.</dd>
</dl></div>
</dd>
<dt id="classes.Visual_DAB.Visual_DAB.get_removed_samples"><code class="name flex">
<span>def <span class="ident">get_removed_samples</span></span>(<span>self, Xmin: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_removed_samples(self, Xmin: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return filtered minority samples after removing noise.

    This method is intended for debugging only. It exposes the internal
    noise removal process used in the DAB_SMOTE algorithm to identify and
    remove outliers from the minority class.

    Parameters
    ----------
    Xmin : np.ndarray
        Array containing minority class samples.

    Returns
    -------
    np.ndarray
        Filtered array of minority class samples with noisy instances removed.
    &#34;&#34;&#34;
    return self._removeNoisySamples(Xmin)</code></pre>
</details>
<div class="desc"><p>Return filtered minority samples after removing noise.</p>
<p>This method is intended for debugging only. It exposes the internal
noise removal process used in the DAB_SMOTE algorithm to identify and
remove outliers from the minority class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xmin</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array containing minority class samples.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Filtered array of minority class samples with noisy instances removed.</dd>
</dl></div>
</dd>
<dt id="classes.Visual_DAB.Visual_DAB.get_screened_boundaries"><code class="name flex">
<span>def <span class="ident">get_screened_boundaries</span></span>(<span>self, Xmin: numpy.ndarray, clusters: numpy.ndarray) ‑> list[numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screened_boundaries(self, Xmin: np.ndarray, clusters: np.ndarray) -&gt; list[np.ndarray]:
    &#34;&#34;&#34;
    Return detected boundary samples of the minority class clusters.

    Identifies boundary samples based on deviation from cluster means and
    standard deviations, which are used later to guide synthetic sample generation.

    Parameters
    ----------
    Xmin : np.ndarray
        Minority class samples.
    clusters : np.ndarray
        Array of cluster labels corresponding to each sample.

    Returns
    -------
    list of np.ndarray
        List containing arrays of boundary samples for each cluster.
    &#34;&#34;&#34;
    return self._screenBoundarySamples(Xmin, clusters)</code></pre>
</details>
<div class="desc"><p>Return detected boundary samples of the minority class clusters.</p>
<p>Identifies boundary samples based on deviation from cluster means and
standard deviations, which are used later to guide synthetic sample generation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xmin</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Minority class samples.</dd>
<dt><strong><code>clusters</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array of cluster labels corresponding to each sample.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>np.ndarray</code></dt>
<dd>List containing arrays of boundary samples for each cluster.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="classes.DAB_SMOTE.DAB_SMOTE" href="DAB_SMOTE.html#classes.DAB_SMOTE.DAB_SMOTE">DAB_SMOTE</a></b></code>:
<ul class="hlist">
<li><code><a title="classes.DAB_SMOTE.DAB_SMOTE.fit_resample" href="DAB_SMOTE.html#classes.DAB_SMOTE.DAB_SMOTE.fit_resample">fit_resample</a></code></li>
<li><code><a title="classes.DAB_SMOTE.DAB_SMOTE.summary" href="DAB_SMOTE.html#classes.DAB_SMOTE.DAB_SMOTE.summary">summary</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="classes" href="index.html">classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="classes.Visual_DAB.Visual_DAB" href="#classes.Visual_DAB.Visual_DAB">Visual_DAB</a></code></h4>
<ul class="">
<li><code><a title="classes.Visual_DAB.Visual_DAB.get_clustering" href="#classes.Visual_DAB.Visual_DAB.get_clustering">get_clustering</a></code></li>
<li><code><a title="classes.Visual_DAB.Visual_DAB.get_generated_samples" href="#classes.Visual_DAB.Visual_DAB.get_generated_samples">get_generated_samples</a></code></li>
<li><code><a title="classes.Visual_DAB.Visual_DAB.get_removed_samples" href="#classes.Visual_DAB.Visual_DAB.get_removed_samples">get_removed_samples</a></code></li>
<li><code><a title="classes.Visual_DAB.Visual_DAB.get_screened_boundaries" href="#classes.Visual_DAB.Visual_DAB.get_screened_boundaries">get_screened_boundaries</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
